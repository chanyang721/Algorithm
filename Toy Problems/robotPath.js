const robotPath = function (room, src, dst) {
    // TODO: 여기에 코드를 작성합니다.
    // 1은 장애물, 0은 이동 가능,
    // 1분에 로봇이 1칸씩 이동 가능
    // 로봇의 위치src(0,0)와 목표지점dst(1,1)이 주어진다. 
    // 순서는   y좌표(요소배열의 인덱스), x좌표(배열의 인덱스) 이다.
    // 로봇이 목표지점이 도달하는 최소시간을 구한다. 
    //// 수도 코드 ////   
    // 각 방향별로 배열을 정한다. 
    // 현재 방향별로 이동하는 인덱스를 y x 순서대로 넣는다. 
    // 각 방향을 저장하는 이동 객체를 만든다.
    // 최단거리로 갈 수 있는 판단 근거 ->
    //   이동이 가능하다 
    //   목표와 가장 y, x를 비교해서 가까운 경로로 이동
    // 1. 최단거리를 구한다. 
    // 2. 최단거리로 이동 중 장애물을 만나면 장애물이 포함된 요소배열에서 이동 가능한 경로0를 찾는다. 
    // 3. 현재위치와 가장 가까운 이동 가능한 경로를 찾고, 이동해야하는 횟수를 더하고 그 위치로 현재위치를 바꾼다.
    // [4, 2] -> [3, 2] -> [2, 2]
    // [4, 2] -> [4, 3] -> [4, 4] -> [4, 5] -> [3, 5] -> [2, 5] ----> [2, 2];
    // [4, 2] -> y+1, x+3 & [3, 5]이동 -> |y-1|, |x-3| & [2, 2]이동 === 8 
    const aux = (M, N, now, step) => {
        const [row, col] = now;
        if (row < 0 || row >= M || col < 0 || col >= N) return; 

        if (room[row][col] === 0 || room[row][col] > step) {
        // 지나온 길을 다시가지 않기 위해 막는다
        // 0 현재위치에서 step이 1이면 2로 증가시킨다
        room[row][col] = step;
        }
        else {
        // dfs 방식 최단거리 탐색// 
            aux(M, N, [row + 1, col], step + 1)
            aux(M, N, [row - 1, col], step + 1)
            aux(M, N, [row, col + 1], step + 1)
            aux(M, N, [row, col - 1], step + 1)
        }
    }

    aux(room.length, room[0].length, src, 1);
    const [r, c] = dst;
    return room[r][c] - 1;
};